;
; File generated by cc65 v 2.18 - Git dc4142e
;
	.fopt		compiler,"cc65 v 2.18 - Git dc4142e"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_pal_bg
	.import		_pal_spr
	.import		_ppu_wait_nmi
	.import		_ppu_off
	.import		_ppu_on_all
	.import		_oam_clear
	.import		_oam_meta_spr
	.import		_pad_poll
	.import		_bank_spr
	.import		_vram_adr
	.import		_vram_put
	.import		_vram_write
	.import		_vram_unrle
	.import		_memcpy
	.import		_memfill
	.import		_get_pad_new
	.import		_get_frame_count
	.import		_set_scroll_x
	.export		_bankLevel
	.export		_bankBuffer
	.export		_banked_call
	.export		_bank_push
	.export		_bank_pop
	.import		_set_prg_8000
	.import		_set_chr_mode_5
	.import		_set_mirroring
	.import		_set_irq_ptr
	.import		_is_irq_done
	.export		_RoundSprL
	.export		_RoundSprR
	.export		_ninja_scene
	.export		_arg1
	.export		_arg2
	.export		_pad1
	.export		_pad1_new
	.export		_char_state
	.export		_scroll_top
	.export		_scroll2
	.export		_scroll3
	.export		_scroll4
	.export		_temp
	.export		_sprite_x
	.export		_sprite_y
	.export		_dirLR
	.export		_irq_array
	.export		_double_buffer
	.export		_wram_array
	.export		_palette_bg
	.export		_palette_spr
	.export		_TEXT0
	.export		_function_bank0
	.export		_TEXT1
	.export		_function_bank2
	.export		_function_bank1
	.export		_TEXT2
	.export		_function_same_bank
	.export		_TEXT3
	.export		_function_bank3
	.export		_TEXT6
	.export		_function_bank6
	.export		_text
	.export		_draw_sprites
	.export		_main

.segment	"RODATA"

.segment	"STARTUP"
_RoundSprL:
	.byte	$FF
	.byte	$FF
	.byte	$02
	.byte	$00
	.byte	$07
	.byte	$FF
	.byte	$03
	.byte	$00
	.byte	$FF
	.byte	$07
	.byte	$12
	.byte	$00
	.byte	$07
	.byte	$07
	.byte	$13
	.byte	$00
	.byte	$80
_RoundSprR:
	.byte	$FF
	.byte	$FF
	.byte	$00
	.byte	$00
	.byte	$07
	.byte	$FF
	.byte	$01
	.byte	$00
	.byte	$FF
	.byte	$07
	.byte	$10
	.byte	$00
	.byte	$07
	.byte	$07
	.byte	$11
	.byte	$00
	.byte	$80
_ninja_scene:
	.byte	$60
	.byte	$00
	.byte	$60
	.byte	$BF
	.byte	$01
	.byte	$60
	.byte	$11
	.byte	$02
	.byte	$03
	.byte	$04
	.byte	$05
	.byte	$01
	.byte	$60
	.byte	$02
	.byte	$06
	.byte	$07
	.byte	$01
	.byte	$60
	.byte	$14
	.byte	$06
	.byte	$03
	.byte	$08
	.byte	$09
	.byte	$09
	.byte	$0A
	.byte	$03
	.byte	$0B
	.byte	$02
	.byte	$0C
	.byte	$0A
	.byte	$0B
	.byte	$01
	.byte	$60
	.byte	$07
	.byte	$06
	.byte	$07
	.byte	$01
	.byte	$60
	.byte	$05
	.byte	$06
	.byte	$07
	.byte	$01
	.byte	$02
	.byte	$0C
	.byte	$09
	.byte	$08
	.byte	$0D
	.byte	$08
	.byte	$0D
	.byte	$04
	.byte	$05
	.byte	$08
	.byte	$0D
	.byte	$04
	.byte	$05
	.byte	$0E
	.byte	$01
	.byte	$60
	.byte	$02
	.byte	$0E
	.byte	$02
	.byte	$0E
	.byte	$02
	.byte	$0C
	.byte	$09
	.byte	$03
	.byte	$0B
	.byte	$0E
	.byte	$02
	.byte	$0E
	.byte	$02
	.byte	$0C
	.byte	$09
	.byte	$03
	.byte	$09
	.byte	$08
	.byte	$09
	.byte	$08
	.byte	$0F
	.byte	$08
	.byte	$0F
	.byte	$09
	.byte	$0A
	.byte	$08
	.byte	$0F
	.byte	$09
	.byte	$0A
	.byte	$0A
	.byte	$0B
	.byte	$0E
	.byte	$01
	.byte	$0A
	.byte	$0D
	.byte	$0A
	.byte	$0D
	.byte	$08
	.byte	$0D
	.byte	$0A
	.byte	$0D
	.byte	$0A
	.byte	$0D
	.byte	$0A
	.byte	$0D
	.byte	$08
	.byte	$0D
	.byte	$0A
	.byte	$0D
	.byte	$0A
	.byte	$0D
	.byte	$0A
	.byte	$0D
	.byte	$0A
	.byte	$0D
	.byte	$0A
	.byte	$0D
	.byte	$08
	.byte	$0D
	.byte	$0A
	.byte	$0D
	.byte	$0A
	.byte	$0D
	.byte	$0A
	.byte	$03
	.byte	$10
	.byte	$11
	.byte	$10
	.byte	$11
	.byte	$10
	.byte	$11
	.byte	$10
	.byte	$11
	.byte	$10
	.byte	$11
	.byte	$10
	.byte	$11
	.byte	$10
	.byte	$11
	.byte	$10
	.byte	$11
	.byte	$10
	.byte	$11
	.byte	$10
	.byte	$11
	.byte	$10
	.byte	$11
	.byte	$10
	.byte	$11
	.byte	$10
	.byte	$11
	.byte	$10
	.byte	$11
	.byte	$10
	.byte	$11
	.byte	$10
	.byte	$11
	.byte	$12
	.byte	$13
	.byte	$12
	.byte	$13
	.byte	$12
	.byte	$14
	.byte	$12
	.byte	$14
	.byte	$15
	.byte	$16
	.byte	$15
	.byte	$16
	.byte	$12
	.byte	$13
	.byte	$12
	.byte	$14
	.byte	$15
	.byte	$16
	.byte	$15
	.byte	$16
	.byte	$15
	.byte	$16
	.byte	$15
	.byte	$16
	.byte	$12
	.byte	$14
	.byte	$12
	.byte	$14
	.byte	$12
	.byte	$14
	.byte	$12
	.byte	$14
	.byte	$17
	.byte	$18
	.byte	$17
	.byte	$18
	.byte	$17
	.byte	$18
	.byte	$17
	.byte	$18
	.byte	$17
	.byte	$18
	.byte	$17
	.byte	$18
	.byte	$17
	.byte	$18
	.byte	$17
	.byte	$18
	.byte	$17
	.byte	$18
	.byte	$17
	.byte	$18
	.byte	$17
	.byte	$18
	.byte	$17
	.byte	$18
	.byte	$17
	.byte	$18
	.byte	$17
	.byte	$18
	.byte	$17
	.byte	$18
	.byte	$17
	.byte	$18
	.byte	$19
	.byte	$1A
	.byte	$60
	.byte	$04
	.byte	$1B
	.byte	$1A
	.byte	$60
	.byte	$06
	.byte	$1B
	.byte	$1A
	.byte	$60
	.byte	$06
	.byte	$1B
	.byte	$1A
	.byte	$60
	.byte	$03
	.byte	$1C
	.byte	$00
	.byte	$60
	.byte	$03
	.byte	$1D
	.byte	$1E
	.byte	$1F
	.byte	$60
	.byte	$03
	.byte	$20
	.byte	$1F
	.byte	$60
	.byte	$06
	.byte	$20
	.byte	$1F
	.byte	$60
	.byte	$06
	.byte	$20
	.byte	$1F
	.byte	$60
	.byte	$03
	.byte	$20
	.byte	$00
	.byte	$60
	.byte	$03
	.byte	$21
	.byte	$22
	.byte	$23
	.byte	$24
	.byte	$25
	.byte	$26
	.byte	$27
	.byte	$22
	.byte	$28
	.byte	$29
	.byte	$60
	.byte	$03
	.byte	$2A
	.byte	$23
	.byte	$27
	.byte	$60
	.byte	$02
	.byte	$22
	.byte	$23
	.byte	$27
	.byte	$60
	.byte	$04
	.byte	$22
	.byte	$2B
	.byte	$2C
	.byte	$00
	.byte	$60
	.byte	$03
	.byte	$21
	.byte	$22
	.byte	$2D
	.byte	$2E
	.byte	$2F
	.byte	$30
	.byte	$31
	.byte	$22
	.byte	$32
	.byte	$33
	.byte	$60
	.byte	$03
	.byte	$34
	.byte	$35
	.byte	$36
	.byte	$60
	.byte	$02
	.byte	$22
	.byte	$35
	.byte	$36
	.byte	$60
	.byte	$04
	.byte	$22
	.byte	$2B
	.byte	$37
	.byte	$00
	.byte	$60
	.byte	$03
	.byte	$21
	.byte	$22
	.byte	$35
	.byte	$36
	.byte	$60
	.byte	$03
	.byte	$22
	.byte	$32
	.byte	$33
	.byte	$60
	.byte	$03
	.byte	$34
	.byte	$35
	.byte	$36
	.byte	$60
	.byte	$02
	.byte	$22
	.byte	$35
	.byte	$36
	.byte	$60
	.byte	$04
	.byte	$22
	.byte	$2B
	.byte	$37
	.byte	$00
	.byte	$60
	.byte	$03
	.byte	$21
	.byte	$22
	.byte	$35
	.byte	$36
	.byte	$60
	.byte	$03
	.byte	$22
	.byte	$32
	.byte	$33
	.byte	$60
	.byte	$03
	.byte	$34
	.byte	$35
	.byte	$36
	.byte	$60
	.byte	$02
	.byte	$22
	.byte	$35
	.byte	$36
	.byte	$60
	.byte	$04
	.byte	$22
	.byte	$2B
	.byte	$37
	.byte	$00
	.byte	$60
	.byte	$03
	.byte	$21
	.byte	$22
	.byte	$35
	.byte	$36
	.byte	$60
	.byte	$02
	.byte	$31
	.byte	$22
	.byte	$32
	.byte	$33
	.byte	$60
	.byte	$03
	.byte	$34
	.byte	$35
	.byte	$36
	.byte	$60
	.byte	$02
	.byte	$22
	.byte	$35
	.byte	$36
	.byte	$60
	.byte	$04
	.byte	$22
	.byte	$2B
	.byte	$2C
	.byte	$00
	.byte	$60
	.byte	$03
	.byte	$21
	.byte	$22
	.byte	$38
	.byte	$39
	.byte	$39
	.byte	$36
	.byte	$36
	.byte	$22
	.byte	$3A
	.byte	$3B
	.byte	$60
	.byte	$03
	.byte	$3C
	.byte	$35
	.byte	$36
	.byte	$60
	.byte	$02
	.byte	$22
	.byte	$38
	.byte	$39
	.byte	$60
	.byte	$02
	.byte	$3D
	.byte	$3D
	.byte	$22
	.byte	$2B
	.byte	$37
	.byte	$00
	.byte	$60
	.byte	$03
	.byte	$3E
	.byte	$3F
	.byte	$40
	.byte	$60
	.byte	$05
	.byte	$41
	.byte	$42
	.byte	$60
	.byte	$09
	.byte	$3F
	.byte	$40
	.byte	$60
	.byte	$05
	.byte	$41
	.byte	$3F
	.byte	$00
	.byte	$60
	.byte	$03
	.byte	$43
	.byte	$44
	.byte	$45
	.byte	$46
	.byte	$47
	.byte	$48
	.byte	$48
	.byte	$49
	.byte	$00
	.byte	$60
	.byte	$02
	.byte	$4A
	.byte	$4B
	.byte	$4C
	.byte	$4B
	.byte	$4D
	.byte	$00
	.byte	$60
	.byte	$03
	.byte	$45
	.byte	$46
	.byte	$47
	.byte	$48
	.byte	$48
	.byte	$49
	.byte	$4A
	.byte	$4E
	.byte	$4F
	.byte	$50
	.byte	$4F
	.byte	$50
	.byte	$51
	.byte	$51
	.byte	$52
	.byte	$53
	.byte	$51
	.byte	$51
	.byte	$54
	.byte	$55
	.byte	$51
	.byte	$60
	.byte	$0B
	.byte	$52
	.byte	$53
	.byte	$51
	.byte	$51
	.byte	$54
	.byte	$55
	.byte	$51
	.byte	$60
	.byte	$05
	.byte	$56
	.byte	$57
	.byte	$56
	.byte	$57
	.byte	$56
	.byte	$57
	.byte	$56
	.byte	$57
	.byte	$56
	.byte	$57
	.byte	$56
	.byte	$57
	.byte	$56
	.byte	$58
	.byte	$56
	.byte	$57
	.byte	$56
	.byte	$57
	.byte	$56
	.byte	$57
	.byte	$56
	.byte	$57
	.byte	$56
	.byte	$57
	.byte	$56
	.byte	$57
	.byte	$56
	.byte	$57
	.byte	$56
	.byte	$57
	.byte	$56
	.byte	$57
	.byte	$59
	.byte	$5A
	.byte	$5B
	.byte	$5C
	.byte	$59
	.byte	$5A
	.byte	$5B
	.byte	$5C
	.byte	$5B
	.byte	$60
	.byte	$07
	.byte	$5D
	.byte	$5C
	.byte	$5D
	.byte	$60
	.byte	$02
	.byte	$5C
	.byte	$5D
	.byte	$5D
	.byte	$59
	.byte	$5A
	.byte	$5B
	.byte	$5C
	.byte	$5B
	.byte	$60
	.byte	$03
	.byte	$5E
	.byte	$5F
	.byte	$5E
	.byte	$5F
	.byte	$5E
	.byte	$5F
	.byte	$5E
	.byte	$5F
	.byte	$5E
	.byte	$5F
	.byte	$5E
	.byte	$5F
	.byte	$5E
	.byte	$5F
	.byte	$5E
	.byte	$5F
	.byte	$5E
	.byte	$5F
	.byte	$5E
	.byte	$5F
	.byte	$5E
	.byte	$5F
	.byte	$5E
	.byte	$5F
	.byte	$5E
	.byte	$5F
	.byte	$5E
	.byte	$5F
	.byte	$5E
	.byte	$5F
	.byte	$5E
	.byte	$5F
	.byte	$00
	.byte	$60
	.byte	$47
	.byte	$A0
	.byte	$60
	.byte	$07
	.byte	$AA
	.byte	$60
	.byte	$07
	.byte	$05
	.byte	$60
	.byte	$07
	.byte	$44
	.byte	$55
	.byte	$00
	.byte	$44
	.byte	$55
	.byte	$55
	.byte	$11
	.byte	$00
	.byte	$04
	.byte	$05
	.byte	$00
	.byte	$04
	.byte	$05
	.byte	$05
	.byte	$01
	.byte	$00
	.byte	$50
	.byte	$60
	.byte	$07
	.byte	$00
	.byte	$60
	.byte	$06
	.byte	$00
	.byte	$60
	.byte	$00
_palette_bg:
	.byte	$0F
	.byte	$0C
	.byte	$1C
	.byte	$3C
	.byte	$0F
	.byte	$0A
	.byte	$19
	.byte	$39
	.byte	$0F
	.byte	$17
	.byte	$26
	.byte	$21
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
_palette_spr:
	.byte	$0F
	.byte	$09
	.byte	$19
	.byte	$29
	.byte	$0F
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0F
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0F
	.byte	$00
	.byte	$00
	.byte	$00
.segment	"BANK0"
_TEXT0:
	.byte	$42,$41,$4E,$4B,$30,$00
.segment	"BANK1"
_TEXT1:
	.byte	$42,$41,$4E,$4B,$31,$00
.segment	"BANK2"
_TEXT2:
	.byte	$42,$41,$4E,$4B,$32,$00
.segment	"BANK3"
_TEXT3:
	.byte	$42,$41,$4E,$4B,$33,$00
.segment	"BANK6"
_TEXT6:
	.byte	$42,$41,$4E,$4B,$36,$00
.segment	"CODE"
_text:
	.byte	$42,$41,$43,$4B,$20,$49,$4E,$20,$46,$49,$58,$45,$44,$20,$42,$41
	.byte	$4E,$4B,$00

.segment	"BSS"

_bankLevel:
	.res	1,$00
_bankBuffer:
	.res	10,$00
.segment	"ZEROPAGE"
_arg1:
	.res	1,$00
_arg2:
	.res	1,$00
_pad1:
	.res	1,$00
_pad1_new:
	.res	1,$00
_char_state:
	.res	1,$00
_scroll_top:
	.res	2,$00
_scroll2:
	.res	2,$00
_scroll3:
	.res	2,$00
_scroll4:
	.res	2,$00
_temp:
	.res	1,$00
_sprite_x:
	.res	1,$00
_sprite_y:
	.res	1,$00
_dirLR:
	.res	1,$00
.segment	"BSS"
_irq_array:
	.res	32,$00
_double_buffer:
	.res	32,$00
.segment	"XRAM"
_wram_array:
	.res	8192,$00

; ---------------------------------------------------------------
; void __near__ banked_call (unsigned char, __near__ __near__ function returning void *)
; ---------------------------------------------------------------

.segment	"STARTUP"

.proc	_banked_call: near

.segment	"STARTUP"

;
; void banked_call(unsigned char bankId, void (*method)(void)) {
;
	jsr     pushax
;
; bank_push(bankId);
;
	ldy     #$02
	lda     (sp),y
	jsr     _bank_push
;
; (*method)();
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     callax
;
; bank_pop();
;
	jsr     _bank_pop
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ bank_push (unsigned char)
; ---------------------------------------------------------------

.segment	"STARTUP"

.proc	_bank_push: near

.segment	"STARTUP"

;
; void bank_push(unsigned char bankId) {
;
	jsr     pusha
;
; bankBuffer[bankLevel] = bankId;
;
	ldy     #$00
	lda     (sp),y
	ldy     _bankLevel
	sta     _bankBuffer,y
;
; ++bankLevel;
;
	inc     _bankLevel
;
; set_prg_8000(bankId);
;
	ldy     #$00
	lda     (sp),y
	jsr     _set_prg_8000
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ bank_pop (void)
; ---------------------------------------------------------------

.segment	"STARTUP"

.proc	_bank_pop: near

.segment	"STARTUP"

;
; --bankLevel;
;
	dec     _bankLevel
;
; if (bankLevel > 0) {
;
	beq     L0014
;
; set_prg_8000(bankBuffer[bankLevel-1]);
;
	ldx     #$00
	lda     _bankLevel
	sec
	sbc     #$01
	bcs     L0019
	dex
L0019:	sta     ptr1
	txa
	clc
	adc     #>(_bankBuffer)
	sta     ptr1+1
	ldy     #<(_bankBuffer)
	lda     (ptr1),y
	jmp     _set_prg_8000
;
; }
;
L0014:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ function_bank0 (void)
; ---------------------------------------------------------------

.segment	"BANK0"

.proc	_function_bank0: near

.segment	"BANK0"

;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(NTADR_A(1,4));
;
	ldx     #$20
	lda     #$81
	jsr     _vram_adr
;
; vram_write(TEXT0,sizeof(TEXT0));
;
	lda     #<(_TEXT0)
	ldx     #>(_TEXT0)
	jsr     pushax
	ldx     #$00
	lda     #$06
	jsr     _vram_write
;
; ppu_on_all();
;
	jmp     _ppu_on_all

.endproc

; ---------------------------------------------------------------
; void __near__ function_bank2 (void)
; ---------------------------------------------------------------

.segment	"BANK2"

.proc	_function_bank2: near

.segment	"BANK2"

;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(NTADR_A(1,8));
;
	ldx     #$21
	lda     #$01
	jsr     _vram_adr
;
; vram_write(TEXT2,sizeof(TEXT2));
;
	lda     #<(_TEXT2)
	ldx     #>(_TEXT2)
	jsr     pushax
	ldx     #$00
	lda     #$06
	jsr     _vram_write
;
; function_same_bank();
;
	jsr     _function_same_bank
;
; ppu_on_all();
;
	jmp     _ppu_on_all

.endproc

; ---------------------------------------------------------------
; void __near__ function_bank1 (void)
; ---------------------------------------------------------------

.segment	"BANK1"

.proc	_function_bank1: near

.segment	"BANK1"

;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(NTADR_A(1,6));
;
	ldx     #$20
	lda     #$C1
	jsr     _vram_adr
;
; vram_write(TEXT1,sizeof(TEXT1));
;
	lda     #<(_TEXT1)
	ldx     #>(_TEXT1)
	jsr     pushax
	ldx     #$00
	lda     #$06
	jsr     _vram_write
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; banked_call(2, function_bank2);
;
	lda     #$02
	jsr     pusha
	lda     #<(_function_bank2)
	ldx     #>(_function_bank2)
	jmp     _banked_call

.endproc

; ---------------------------------------------------------------
; void __near__ function_same_bank (void)
; ---------------------------------------------------------------

.segment	"BANK2"

.proc	_function_same_bank: near

.segment	"BANK2"

;
; vram_put(0);
;
	lda     #$00
	jsr     _vram_put
;
; vram_put('H');
;
	lda     #$48
	jsr     _vram_put
;
; vram_put('I');
;
	lda     #$49
	jmp     _vram_put

.endproc

; ---------------------------------------------------------------
; void __near__ function_bank3 (void)
; ---------------------------------------------------------------

.segment	"BANK3"

.proc	_function_bank3: near

.segment	"BANK3"

;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(NTADR_A(1,10));
;
	ldx     #$21
	lda     #$41
	jsr     _vram_adr
;
; vram_write(TEXT3,sizeof(TEXT3));
;
	lda     #<(_TEXT3)
	ldx     #>(_TEXT3)
	jsr     pushax
	ldx     #$00
	lda     #$06
	jsr     _vram_write
;
; vram_put(0);
;
	lda     #$00
	jsr     _vram_put
;
; vram_put(arg1); // these args were passed via globals
;
	lda     _arg1
	jsr     _vram_put
;
; vram_put(arg2);
;
	lda     _arg2
	jsr     _vram_put
;
; ppu_on_all();
;
	jmp     _ppu_on_all

.endproc

; ---------------------------------------------------------------
; void __near__ function_bank6 (void)
; ---------------------------------------------------------------

.segment	"BANK6"

.proc	_function_bank6: near

.segment	"BANK6"

;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(NTADR_A(1,14));
;
	ldx     #$21
	lda     #$C1
	jsr     _vram_adr
;
; vram_write(TEXT6,sizeof(TEXT6));
;
	lda     #<(_TEXT6)
	ldx     #>(_TEXT6)
	jsr     pushax
	ldx     #$00
	lda     #$06
	jsr     _vram_write
;
; vram_put(0);
;
	lda     #$00
	jsr     _vram_put
;
; vram_put(wram_array[0]); // testing the $6000-7fff area
;
	lda     _wram_array
	jsr     _vram_put
;
; vram_put(wram_array[2]); // should print A, C
;
	lda     _wram_array+2
	jsr     _vram_put
;
; ppu_on_all();
;
	jmp     _ppu_on_all

.endproc

; ---------------------------------------------------------------
; void __near__ draw_sprites (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_sprites: near

.segment	"CODE"

;
; oam_clear();
;
	jsr     _oam_clear
;
; if(!dirLR) { // left
;
	lda     _dirLR
	bne     L0488
;
; oam_meta_spr(sprite_x, sprite_y, RoundSprL);
;
	jsr     decsp2
	lda     _sprite_x
	ldy     #$01
	sta     (sp),y
	lda     _sprite_y
	dey
	sta     (sp),y
	lda     #<(_RoundSprL)
	ldx     #>(_RoundSprL)
	jmp     _oam_meta_spr
;
; oam_meta_spr(sprite_x, sprite_y, RoundSprR);
;
L0488:	jsr     decsp2
	lda     _sprite_x
	ldy     #$01
	sta     (sp),y
	lda     _sprite_y
	dey
	sta     (sp),y
	lda     #<(_RoundSprR)
	ldx     #>(_RoundSprR)
	jmp     _oam_meta_spr

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; set_mirroring(MIRROR_HORIZONTAL);
;
	lda     #$01
	jsr     _set_mirroring
;
; bank_spr(1);
;
	lda     #$01
	jsr     _bank_spr
;
; irq_array[0] = 0xff; // end of data
;
	lda     #$FF
	sta     _irq_array
;
; set_irq_ptr(irq_array); // point to this array
;
	lda     #<(_irq_array)
	ldx     #>(_irq_array)
	jsr     _set_irq_ptr
;
; memfill(wram_array,0,0x2000); 
;
	jsr     decsp3
	lda     #<(_wram_array)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_wram_array)
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	ldx     #$20
	jsr     _memfill
;
; wram_array[0] = 'A'; // put some values at $6000-7fff
;
	lda     #$41
	sta     _wram_array
;
; wram_array[2] = 'C'; // for later testing
;
	lda     #$43
	sta     _wram_array+2
;
; ppu_off(); // screen off
;
	jsr     _ppu_off
;
; pal_bg(palette_bg); // load the BG palette
;
	lda     #<(_palette_bg)
	ldx     #>(_palette_bg)
	jsr     _pal_bg
;
; pal_spr(palette_spr); // load the sprite palette
;
	lda     #<(_palette_spr)
	ldx     #>(_palette_spr)
	jsr     _pal_spr
;
; vram_adr(NTADR_A(20,3)); // gear and squares
;
	ldx     #$20
	lda     #$74
	jsr     _vram_adr
;
; vram_put(0xc0);
;
	lda     #$C0
	jsr     _vram_put
;
; vram_put(0xc1);
;
	lda     #$C1
	jsr     _vram_put
;
; vram_put(0xc2);
;
	lda     #$C2
	jsr     _vram_put
;
; vram_put(0xc3);
;
	lda     #$C3
	jsr     _vram_put
;
; vram_adr(NTADR_A(20,4));
;
	ldx     #$20
	lda     #$94
	jsr     _vram_adr
;
; vram_put(0xd0);
;
	lda     #$D0
	jsr     _vram_put
;
; vram_put(0xd1);
;
	lda     #$D1
	jsr     _vram_put
;
; vram_put(0xd2);
;
	lda     #$D2
	jsr     _vram_put
;
; vram_put(0xd3);
;
	lda     #$D3
	jsr     _vram_put
;
; vram_adr(NTADR_A(20,7));
;
	ldx     #$20
	lda     #$F4
	jsr     _vram_adr
;
; vram_put(0xc0);
;
	lda     #$C0
	jsr     _vram_put
;
; vram_put(0xc1);
;
	lda     #$C1
	jsr     _vram_put
;
; vram_put(0xc2);
;
	lda     #$C2
	jsr     _vram_put
;
; vram_put(0xc3);
;
	lda     #$C3
	jsr     _vram_put
;
; vram_adr(NTADR_A(20,8));
;
	ldx     #$21
	lda     #$14
	jsr     _vram_adr
;
; vram_put(0xd0);
;
	lda     #$D0
	jsr     _vram_put
;
; vram_put(0xd1);
;
	lda     #$D1
	jsr     _vram_put
;
; vram_put(0xd2);
;
	lda     #$D2
	jsr     _vram_put
;
; vram_put(0xd3);
;
	lda     #$D3
	jsr     _vram_put
;
; vram_adr(NTADR_A(20,5)); // blocks of color
;
	ldx     #$20
	lda     #$B4
	jsr     _vram_adr
;
; vram_put(0x2);
;
	lda     #$02
	jsr     _vram_put
;
; vram_put(0x2);
;
	lda     #$02
	jsr     _vram_put
;
; vram_put(0x2);
;
	lda     #$02
	jsr     _vram_put
;
; vram_put(0x2);
;
	lda     #$02
	jsr     _vram_put
;
; vram_adr(NTADR_A(20,9));
;
	ldx     #$21
	lda     #$34
	jsr     _vram_adr
;
; vram_put(0x2);
;
	lda     #$02
	jsr     _vram_put
;
; vram_put(0x2);
;
	lda     #$02
	jsr     _vram_put
;
; vram_put(0x2);
;
	lda     #$02
	jsr     _vram_put
;
; vram_put(0x2);
;
	lda     #$02
	jsr     _vram_put
;
; vram_adr(NTADR_A(20,13));
;
	ldx     #$21
	lda     #$B4
	jsr     _vram_adr
;
; vram_put(0x2);
;
	lda     #$02
	jsr     _vram_put
;
; vram_put(0x2);
;
	lda     #$02
	jsr     _vram_put
;
; vram_put(0x2);
;
	lda     #$02
	jsr     _vram_put
;
; vram_put(0x2);
;
	lda     #$02
	jsr     _vram_put
;
; set_chr_mode_5(8); // make sure the gear tiles loaded
;
	lda     #$08
	jsr     _set_chr_mode_5
;
; banked_call(0, function_bank0);
;
	lda     #$00
	jsr     pusha
	lda     #<(_function_bank0)
	ldx     #>(_function_bank0)
	jsr     _banked_call
;
; banked_call(1, function_bank1);
;
	lda     #$01
	jsr     pusha
	lda     #<(_function_bank1)
	ldx     #>(_function_bank1)
	jsr     _banked_call
;
; arg1 = 'G'; // must pass arguments with globals
;
	lda     #$47
	sta     _arg1
;
; arg2 = '4';
;
	lda     #$34
	sta     _arg2
;
; banked_call(3, function_bank3);
;
	lda     #$03
	jsr     pusha
	lda     #<(_function_bank3)
	ldx     #>(_function_bank3)
	jsr     _banked_call
;
; banked_call(6, function_bank6);
;
	lda     #$06
	jsr     pusha
	lda     #<(_function_bank6)
	ldx     #>(_function_bank6)
	jsr     _banked_call
;
; ppu_off(); // screen off
;
	jsr     _ppu_off
;
; vram_adr(NTADR_A(1,16));
;
	ldx     #$22
	lda     #$01
	jsr     _vram_adr
;
; vram_write(text,sizeof(text));
;
	lda     #<(_text)
	ldx     #>(_text)
	jsr     pushax
	ldx     #$00
	lda     #$13
	jsr     _vram_write
;
; sprite_x = 0x50;
;
	lda     #$50
	sta     _sprite_x
;
; sprite_y = 0x30;
;
	lda     #$30
	sta     _sprite_y
;
; draw_sprites();
;
	jsr     _draw_sprites
;
; vram_adr(NTADR_A(0,0));
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; vram_unrle(ninja_scene);
;
	lda     #<(_ninja_scene)
	ldx     #>(_ninja_scene)
	jsr     _vram_unrle
;
; ppu_on_all(); // turn on screen
;
	jsr     _ppu_on_all
;
; ppu_wait_nmi();
;
L03F5:	jsr     _ppu_wait_nmi
;
; pad1 = pad_poll(0);
;
	lda     #$00
	jsr     _pad_poll
	sta     _pad1
;
; pad1_new = get_pad_new(0);
;
	lda     #$00
	jsr     _get_pad_new
	sta     _pad1_new
;
; if(pad1 & PAD_A){ // shift screen right = subtract from scroll
;
	lda     _pad1
	and     #$80
	beq     L0495
;
; scroll_top -= 0x80; // sub pixel movement
;
	lda     _scroll_top
	sec
	sbc     #$80
	sta     _scroll_top
	bcs     L0404
	dec     _scroll_top+1
;
; scroll2 -= 0x30; // 1 pixel
;
L0404:	lda     _scroll2
	sec
	sbc     #$30
	sta     _scroll2
	bcs     L0407
	dec     _scroll2+1
;
; scroll3 -= 0x180;
;
L0407:	lda     _scroll3
	sec
	sbc     #$80
	sta     _scroll3
	lda     _scroll3+1
	sbc     #$01
	sta     _scroll3+1
;
; scroll4 -= 0x300; 
;
	lda     _scroll4
	sec
	sbc     #$00
	sta     _scroll4
	lda     _scroll4+1
	sbc     #$03
	sta     _scroll4+1
;
; if(pad1 & PAD_B){ // shift screen right = subtract from scroll
;
L0495:	lda     _pad1
	and     #$40
	beq     L0496
;
; scroll_top += 0x80; // sub pixel movement
;
	lda     #$80
	clc
	adc     _scroll_top
	sta     _scroll_top
	bcc     L0410
	inc     _scroll_top+1
;
; scroll2 += 0x50; // 1 pixel
;
L0410:	lda     #$50
	clc
	adc     _scroll2
	sta     _scroll2
	bcc     L0413
	inc     _scroll2+1
;
; scroll3 += 0x200;
;
L0413:	lda     #$00
	clc
	adc     _scroll3
	sta     _scroll3
	lda     #$02
	adc     _scroll3+1
	sta     _scroll3+1
;
; scroll4 += 0x500;
;
	lda     #$00
	clc
	adc     _scroll4
	sta     _scroll4
	lda     #$05
	adc     _scroll4+1
	sta     _scroll4+1
;
; temp = scroll_top >> 8;
;
L0496:	lda     _scroll_top+1
	sta     _temp
;
; set_scroll_x(temp);
;
	ldx     #$00
	jsr     _set_scroll_x
;
; if((get_frame_count() & 0x03) == 0){ // every 4th frame
;
	jsr     _get_frame_count
	and     #$03
	bne     L0497
;
; ++char_state;
;
	inc     _char_state
;
; if(char_state >=4) char_state = 0;
;
	lda     _char_state
	cmp     #$04
	bcc     L0497
	lda     #$00
	sta     _char_state
;
; double_buffer[0] = 0xfc; // CHR mode 5, change the 0xc00-0xfff tiles
;
L0497:	lda     #$FC
	sta     _double_buffer
;
; double_buffer[1] = 8; // top of the screen, static value
;
	lda     #$08
	sta     _double_buffer+1
;
; double_buffer[2] = 47; // value < 0xf0 = scanline count, 1 less than #
;
	lda     #$2F
	sta     _double_buffer+2
;
; double_buffer[3] = 0xf5; // H scroll change, do first for timing
;
	lda     #$F5
	sta     _double_buffer+3
;
; temp = scroll2 >> 8;
;
	lda     _scroll2+1
	sta     _temp
;
; double_buffer[4] = temp; // scroll value
;
	sta     _double_buffer+4
;
; double_buffer[5] = 0xfc; // CHR mode 5, change the 0xc00-0xfff tiles
;
	lda     #$FC
	sta     _double_buffer+5
;
; double_buffer[6] = 8 + char_state; // value = 8,9,10,or 11
;
	lda     _char_state
	clc
	adc     #$08
	sta     _double_buffer+6
;
; double_buffer[7] = 29 + 16; // scanline count
;
	lda     #$2D
	sta     _double_buffer+7
;
; double_buffer[8] = 0xf5; // H scroll change
;
	lda     #$F5
	sta     _double_buffer+8
;
; temp = scroll3 >> 8;
;
	lda     _scroll3+1
	sta     _temp
;
; double_buffer[9] = temp; // scroll value
;
	sta     _double_buffer+9
;
; double_buffer[10] = 0xf1; // $2001 test changing color emphasis
;
	lda     #$F1
	sta     _double_buffer+10
;
; double_buffer[11] = 0xfe; // value COL_EMP_DARK 0xe0 + 0x1e
;
	lda     #$FE
	sta     _double_buffer+11
;
; double_buffer[12] = 15 ; // scanline count
;
	lda     #$0F
	sta     _double_buffer+12
;
; double_buffer[13] = 0xf5; // H scroll change
;
	lda     #$F5
	sta     _double_buffer+13
;
; double_buffer[14] = 0; // scroll value (none)
;
	lda     #$00
	sta     _double_buffer+14
;
; double_buffer[15] = 82 + 2; // scanline count
;
	lda     #$54
	sta     _double_buffer+15
;
; double_buffer[16] = 0xf5; // H scroll change
;
	lda     #$F5
	sta     _double_buffer+16
;
; temp = scroll4 >> 8;
;
	lda     _scroll4+1
	sta     _temp
;
; double_buffer[17] = temp; // scroll value
;
	sta     _double_buffer+17
;
; double_buffer[18] = 0xff; // end of data
;
	lda     #$FF
	sta     _double_buffer+18
;
; if(pad1 & PAD_LEFT){ // shift screen right = subtract from scroll
;
	lda     _pad1
	and     #$02
	beq     L0498
;
; sprite_x -= 1;
;
	dec     _sprite_x
;
; dirLR = 0;
;
	lda     #$00
;
; else if(pad1 & PAD_RIGHT){ // shift screen right = subtract from scroll
;
	jmp     L0493
L0498:	lda     _pad1
	and     #$01
	beq     L0499
;
; sprite_x += 1;
;
	inc     _sprite_x
;
; dirLR = 1;
;
	lda     #$01
L0493:	sta     _dirLR
;
; if(pad1 & PAD_UP){ // shift screen right = subtract from scroll
;
L0499:	lda     _pad1
	and     #$08
	beq     L049A
;
; sprite_y -= 1;
;
	dec     _sprite_y
;
; else if(pad1 & PAD_DOWN){ // shift screen right = subtract from scroll
;
	jmp     L0477
L049A:	lda     _pad1
	and     #$04
	beq     L0477
;
; sprite_y += 1;
;
	inc     _sprite_y
;
; draw_sprites();
;
L0477:	jsr     _draw_sprites
;
; while(!is_irq_done() ){ // have we reached the 0xff, end of data
;
L047C:	jsr     _is_irq_done
	tax
	beq     L047C
;
; memcpy(irq_array, double_buffer, sizeof(irq_array)); 
;
	ldy     #$1F
L0485:	lda     _double_buffer,y
	sta     _irq_array,y
	dey
	bpl     L0485
;
; while (1){ // infinite loop
;
	jmp     L03F5

.endproc

